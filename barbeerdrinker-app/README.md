# barbeerdrinker extended

rutgers cs 336 project milestone 2

#### Matthew Handzy (mah376), Juan Cruz (jgc112)

## Overview

In this milestone for our project, we were required to populate our database with patterened tuples. In order to accomplish this, we collected information from the internet about popular `bars` in the tri-state area, a list of the most popular `beers` in the area, and created synthetic but realistic identities for `drinkers` at these bars. This required a bit of research and manual data entry, as well as linking the core tables in order to create `frequents`, `likes`, and `sells` tables.

Each individual transaction that occurs at an arbitrary bar is stored in the `transactions` table. Each transaction has a unique transactionID identifier (PK of the table) which allows us to match transactionID's with individuals for further analysis. The details of each transaction are stored in the `bills` table, which enumerates which items were purchased on any given transaction. As storing each item on a bill in the `transactions` table would be redundant and inefficient, we store details of each transaction in a separate table.

We accomplished our data entry with Apple's Pages application (similar to Microsoft Excel), exported tables to csv and uploaded to our AWS RDS instance through MySQLWorkbench. We verified our patterns using SQL queries, and ran simple statistics and number crunching through R in RStudio with the dplyr package before translating . Our final tables are in the `/csv/` directory, and raw files are stored in the `/numbers/` directory.

Creating the base tables that are present in the BarBeerDrinker schema used for homework was trivial: all we had to do was generate tuples, then match those tuples on a set of simple conditions. We were pleased with the results.

Generating `transactions` and `bills` was more complicated - it required us to create realistic reciepts of transactions, subject to time constraints (bar hours), all while matching drinkers with the bars that they frequent. This was a lot more involved and took more work than expected.

## Design

#### `bars`

The bars were scraped from lists of most popular NYC/Hoboken/Hartford bars, then manually entering them into a csv file. We selected a distribution of 50% NYC bars, 33% Hoboken bars, and 16% Hartford, a design choice we made early on. We figured NYC is more popular than Hoboken which is more popular than Hartford for drinking -- arbitrarily. However, we wanted to ensure that the population would be similarly distributed -- this is explored in the `drinkers` section.

#### `beers`

We simply compiled a list of popular beers using a list from the internet as well as prior experience with real beer preferences of our friends. The beers on the list were arbitrarily chosen but the set is diverse and wide enough that it encompasses all the most common beers of choice as well as more obscure but still relevant beers. We wanted to include multiple types of beer offered by similar companies, for example: Coors Light, Coors Banquet; Corona Light, Corona Extra; Michelob Light, Michelob Original, Michelob Premium.

#### `bills`

This table was created using an initial vector of 3,800 unique `transaction_id`'s generated in python. From there, we randomly matched bars to transaction_id's, and from there used the `sells` table to randomly pick food and drink items to put on the bill.

#### `drinkers`

As mentioned before, our main objective with drinkers was keeping similar distributions of location to the bars table. Our generated drinkers dataset contained:
  * 21.7% CT residents
  * 37.2% NJ residents
  * 41.1% NY residents

We found this acceptable, and given the slight difference in distributions could make for some interesting 'finds' later in the data. We then generated unique, random names (pairs of first, last) and assigned phone numbers and street addresses to them. The `city` column is populated with real cities that are within realistic commuting distance to the city where they frequent bars, rather than have cross-state drinkers.

#### `frequents`

In order to link our bars and drinkers, we create a relationship that maps a particular drinker to a particular set of bars that they would frequent. This requires multiple repeat entries in the `drinker` column, multiple repeat entries in the `bar` column, however the combination of any given drinker and bar is unique: thus, no redundancy.

#### `likes`

We randomly paired bars with food and drink items, each with price ranges from which values were randomly assigned to each bar/item combination. We had multiples of bars/food/price pairings along with all bars/beers/price pairings from the `sells` table.

#### `sells`

Our sells table was randomly generated by pairing bars with beers at a given price. A base price was given for each beer, and a random modifier changed the price of the beer from bar-to-bar. The mandatory pattern was asserted when generating this gable.

#### `transactions`

see: `/gen_tables/gen_transac.R`

Using the bills list as an input, this table was generated by reducing distinct transaction_id's and calculating subtotals, injecting a random tip vector (10-20%), and calculating the final price using 7% tax as stated in the project specs.

Then, we identified which bars had which frequenters associated with them, and picked a random drinker to pay for the transaction. Then, a series of logical checks were applied to ensure the timestamp of the transaction was within the open hours of the bar. This ensured our constraints and patterns were satisfied. This table generation accomplished in RStudio using the tidyverse package.

## Constraints

#### mandatory constraints:

- [x] each bar must also have opening and closing hours
- [x] at least 5,000 tuples  in your database instance excluding transactions/bills
- [x] at least 20,000 transactions/bills

#### custom constraints:

- [x] at least 60 bars
- [x] at least 60 beers
- [x] at least 1,000 drinkers
- [x] `beers` table has `rating` and `abv` columns
- [x] `drinkers` from NY, NJ, CT

## Patterns

#### mandatory patterns:

- [x] `transactions` cannot occur at times when a given bar is closed
- [x] `drinkers` cannot frequent bars in different state
- [x] for any two `beers` (b1 and b2) different bars may charge differently for b1 and b2, but b1 should either be less expensive than b2 in all bars, or more expensive than b2 in all bars

#### custom patterns:

- [x] distribution of bars with:
  * 1/2 (50%) of bars in NY
  * 1/3 (33%) of bars in NJ
  * 1/6 (16%) of bars in CT
- [x] bars listed in the following cities:
  * New York City
  * Hoboken
  * Hartford
- [x] multiple types of beer from same manufacturer for some manf's
- [x] reasonably similar drinker home state distributions to bars (within a certain tolerance)

## Connecting to our (real) SQL Database

#### host

`barbeerdrinker.cwbowizjcrlm.us-west-1.rds.amazonaws.com`

#### username

`juanmatthew`

#### password

`password`

#### dbname

`barbeerdrinker` (lowercase, case-sensitive)

#### port

`3306`

## SQL Constraint & Pattern Verification

#### `bars`

###### constraints:
- [x] at least 60 unique bars
- [x] has `open` and `close` columns

###### patterns:
- [x] 1/2 NY, 1/3 NJ, 1/6 CT distribution
- [x] bars in the cities of New York City, Hoboken, and Hartford

###### verification:
this query verifies the 60 bars constraint
~~~sql
select if(count(*) >= 60, 'true', 'false') as result
from (select distinct name
      from barbeerdrinker.bars
      ) tmp
~~~

this query verifies the existence of `open` and `close` columns
~~~sql
select open, close
from barbeerdrinker.bars
~~~

this query verifies our claimed distribution pattern
~~~sql
select left(license, 2) as state, count(*) as distro
from barbeerdrinker.bars
group by state
order by distro desc
~~~

this query verifies the cities pattern
~~~sql
select distinct city as result
from barbeerdrinker.bars
~~~

#### `beers`

###### constraints:
- [x] at least 60 unique beers
- [x] has `rating` and `abv` columns

###### patterns:
- [x] multiple types of beer from same manufacturer for some manf's

###### verification:
this query verifies the 60 beers constraint
~~~sql
select if(count(*) >= 60, 'true', 'false') as result
from (select distinct name
      from barbeerdrinker.beers
      ) tmp
~~~

this query verifies the existence of `rating` and `abv` columns
~~~sql
select rating, abv
from barbeerdrinker.beers
~~~

this query verifies the existence of multiple beers from the same manufacturer (not all have to be true, but at least 1 does)
~~~sql
select manf, if(count(manf) > 1, 'true', 'false') as result
from barbeerdrinker.beers
group by manf
order by result desc
~~~

#### `drinkers`

###### constraints:
- [x] at least 1,000 unique drinkers
- [x] drinkers from NY, NJ, and CT

###### patterns:
- [x] `drinkers` cannot frequent bars in different states
- [x] reasonably similar drinker home state distributions to bars (within a certain tolerance)

###### verification:
this query verifies the 1,000 drinkers constraint
~~~sql
select if(count(*) >= 1000, 'true', 'false') as result
from (select distinct name
      from barbeerdrinker.drinkers
      ) tmp
~~~

this query verifies the location constraint
~~~sql
select distinct right(city, 2) as result
from barbeerdrinker.drinkers
~~~

this query verifies the frequenting pattern
~~~sql
select *
from (select right(d.city, 2) as a, left(b.license, 2) as b
		 from drinkers d, bars b, frequents f
		 where d.name = f.drinker
		 and f.bar = b.name) tmp
where a <> b
~~~

this query verifies that the distributions are not too far off from the distribution of bars in certain states (as stated above)
~~~sql
select state, distro
from (select state, cast(count(state) as unsigned) as distro
		 from (select right(city, 2) as state
				   from barbeerdrinker.drinkers
				   ) tmp
		 group by state) tmp2
~~~

#### `frequents`

###### constraints:

###### patterns:
- [x] not all drinkers must frequent bars (# of distinct frequenters <= # of drinkers)

###### verification:
~~~~sql
select count(distinct drinker) as drinker
from barbeerdrinker.frequents
where !find_in_set(1000, drinker)
~~~~

#### `likes`

###### constraints:
 - no constraints

###### patterns:
 - no patterns

###### verification:
~~~sql
none needed
~~~

#### `sells`

###### constraints:

###### patterns:
- [x] for any two `beers` (b1 and b2) different bars may charge differently for b1 and b2, but b1 should either be less expensive than b2 in all bars, or more expensive than b2 in all bars. since it returns no rows, there are no matches for this.

###### verification:
this query verifies the price differential pattern
~~~sql
select b.name, s1.bar, s1.price, s2.bar, s2.price
from beers b, sells s1, sells s2
where b.name = s1.item
and b.name = s2.item
and s1.price > s2.price
and s2.price > s1.price
~~~

#### `transactions`

###### constraints:
 - none

###### patterns:
- [x] the drinker must frequent the bar at which the transaction occurred in
- [x] `transactions` cannot occur at times when a given bar is closed

###### verification:

this query verifies the frequenting pattern. since it equals 3,800, or the number of transactions, we know all transactions occurred by drinkers that frequent the bars at which the transaction occurred
~~~sql
select count(transaction_id) as result
from (select distinct t.transaction_id, d.name, t.bar_name
		 from bills b, drinkers d, frequents f,  transactions t
		 where d.name = f.drinker
		 and d.name = t.drinker_name
		 and b.transaction_id = t.transaction_id
         ) tmp
~~~

this query verifies that no transactions occurred when bars were closed for bars that open and close on the same day. no results means no out of bounds transactions.
~~~sql
select *
from (select cast(tr.transaction_time as time) as timestamp, ba.open, ba.close
      from transactions tr, bars ba
      where tr.bar_name = ba.name) tmp
where tmp.timestamp between tmp.open and tmp.close
and open > close
~~~

this query verifies that no transactions occurred when bars were closed for bars that open and close on different days (PM open, AM close). no results means no out of bounds transactions.
~~~sql
select *
from (select cast(tr.transaction_time as time) as timestamp, ba.open, ba.close
      from transactions tr, bars ba
      where tr.bar_name = ba.name) tmp
where !(tmp.timestamp between tmp.open and tmp.close)
and close > open
~~~
